<!DOCTYPE html><html lang="en" data-astro-cid-j7pv25f6> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>evalla - Safe math evaluator</title><style>[data-astro-cid-j7pv25f6]{margin:0;padding:0;box-sizing:border-box}body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;line-height:1.6;color:#333;background:#f8f9fa;padding:2rem}.container[data-astro-cid-j7pv25f6]{max-width:900px;margin:0 auto;background:#fff;padding:3rem;border-radius:8px;box-shadow:0 2px 8px #0000001a}.header[data-astro-cid-j7pv25f6]{text-align:center;margin-bottom:3rem;padding-bottom:2rem;border-bottom:2px solid #667eea}.nav[data-astro-cid-j7pv25f6]{display:flex;justify-content:center;gap:2rem;margin-bottom:2rem}.nav[data-astro-cid-j7pv25f6] a[data-astro-cid-j7pv25f6]{padding:.75rem 1.5rem;background:#667eea;color:#fff;text-decoration:none;border-radius:6px;font-weight:600;transition:background .2s}.nav[data-astro-cid-j7pv25f6] a[data-astro-cid-j7pv25f6]:hover{background:#5568d3}.content[data-astro-cid-j7pv25f6] h1[data-astro-cid-j7pv25f6]{color:#667eea;font-size:2.5rem;margin-bottom:1rem}.content[data-astro-cid-j7pv25f6] h2[data-astro-cid-j7pv25f6]{color:#667eea;font-size:1.8rem;margin-top:2.5rem;margin-bottom:1rem;border-bottom:2px solid #e9ecef;padding-bottom:.5rem}.content[data-astro-cid-j7pv25f6] h3[data-astro-cid-j7pv25f6]{color:#495057;font-size:1.4rem;margin-top:2rem;margin-bottom:.75rem}.content[data-astro-cid-j7pv25f6] p[data-astro-cid-j7pv25f6]{margin-bottom:1rem;line-height:1.8}.content[data-astro-cid-j7pv25f6] ul[data-astro-cid-j7pv25f6],.content[data-astro-cid-j7pv25f6] ol[data-astro-cid-j7pv25f6]{margin-bottom:1rem;margin-left:2rem}.content[data-astro-cid-j7pv25f6] li[data-astro-cid-j7pv25f6]{margin-bottom:.5rem;line-height:1.6}.content[data-astro-cid-j7pv25f6] code[data-astro-cid-j7pv25f6]{background:#f8f9fa;padding:.2rem .4rem;border-radius:3px;font-family:Courier New,monospace;font-size:.9em;color:#e83e8c}.content[data-astro-cid-j7pv25f6] pre[data-astro-cid-j7pv25f6]{background:#2d2d2d;color:#f8f8f2;padding:1.5rem;border-radius:6px;overflow-x:auto;margin:1.5rem 0}.content[data-astro-cid-j7pv25f6] pre[data-astro-cid-j7pv25f6] code[data-astro-cid-j7pv25f6]{background:none;padding:0;color:#f8f8f2;font-size:.9rem}.content[data-astro-cid-j7pv25f6] a[data-astro-cid-j7pv25f6]{color:#667eea;text-decoration:none;border-bottom:1px solid transparent;transition:border-color .2s}.content[data-astro-cid-j7pv25f6] a[data-astro-cid-j7pv25f6]:hover{border-bottom-color:#667eea}.content[data-astro-cid-j7pv25f6] strong[data-astro-cid-j7pv25f6]{color:#495057;font-weight:600}@media(max-width:768px){body{padding:1rem}.container[data-astro-cid-j7pv25f6]{padding:1.5rem}.content[data-astro-cid-j7pv25f6] h1[data-astro-cid-j7pv25f6]{font-size:2rem}.content[data-astro-cid-j7pv25f6] h2[data-astro-cid-j7pv25f6]{font-size:1.5rem}}
</style></head> <body data-astro-cid-j7pv25f6> <div class="container" data-astro-cid-j7pv25f6> <div class="header" data-astro-cid-j7pv25f6> <div class="nav" data-astro-cid-j7pv25f6> <a href="./" data-astro-cid-j7pv25f6>üìö Documentation</a> <a href="./playground" data-astro-cid-j7pv25f6>üéÆ Try Playground</a> </div> </div> <!-- Auto-generated by sync-readme.js - DO NOT EDIT MANUALLY --><div class="content"><h1>evalla</h1>
<p>Safe math evaluator with variables, dependencies, and precision.</p>
<h2>Features</h2>
<ul>
<li>‚úÖ <strong>Decimal Precision</strong>: Uses <a href="https://mikemcl.github.io/decimal.js/">decimal.js</a> internally for accurate arithmetic</li>
<li>‚úÖ <strong>Variable References</strong>: Support dependencies between expressions</li>
<li>‚úÖ <strong>Dot-Traversal</strong>: Reference nested properties (e.g., <code>point.x</code>, <code>offset.y</code>)</li>
<li>‚úÖ <strong>Topological Ordering</strong>: Evaluates in correct dependency order (DAG)</li>
<li>‚úÖ <strong>Circular Detection</strong>: Throws error on circular dependencies</li>
<li>‚úÖ <strong>Safe Evaluation</strong>: Parses with <a href="https://peggyjs.org/">Peggy</a> parser, evaluates AST (no <code>eval()</code> or <code>Function()</code>)</li>
<li>‚úÖ <strong>Keywords as Variables</strong>: Unlike JavaScript, keywords like <code>return</code>, <code>if</code>, etc. can be used as variable names</li>
<li>‚úÖ <a href="#namespaces"><strong>Namespaces</strong></a>: Built-in <code>$math</code>, <code>$unit</code>, and <code>$angle</code> functions</li>
</ul>
<h2>Installation</h2>
<pre><code class="language-bash">npm install evalla
</code></pre>
<h3>Input Format</h3>
<pre><code class="language-typescript">interface ExpressionInput {
  name: string;         // Variable name (cannot start with $)
  expr?: string;        // Math expression (optional if value is provided)
  value?: any;          // Direct value (optional if expr is provided)
}
</code></pre>
<p>You must provide either <code>expr</code> or <code>value</code> per item. The <code>value</code> property allows you to pass objects directly without stringifying them into expressions.</p>
<p><strong>Using expressions:</strong></p>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;width&#39;, expr: &#39;100&#39; },
  { name: &#39;height&#39;, expr: &#39;50&#39; }
]);
</code></pre>
<p><strong>Using direct values:</strong></p>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;point&#39;, value: { x: 10, y: 20 } },
  { name: &#39;offset&#39;, value: { x: 5, y: 10 } }
]);
</code></pre>
<p><strong>Mixing both:</strong></p>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;data&#39;, value: { width: 100, height: 50 } },
  { name: &#39;area&#39;, expr: &#39;data.width * data.height&#39; }
]);
</code></pre>
<h3>Output Format</h3>
<pre><code class="language-typescript">interface EvaluationResult {
  values: Record&lt;string, Decimal&gt;;  // Computed values as Decimal objects
  order: string[];                  // Evaluation order (topologically sorted)
}
</code></pre>
<h2>Examples</h2>
<h3>Basic Arithmetic with Precision</h3>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;x&#39;, expr: &#39;0.1 + 0.2&#39; }
]);

console.log(result.values.x.toString()); // &quot;0.3&quot; (exact!)
</code></pre>
<h3>Variable Dependencies</h3>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;d&#39;, expr: &#39;c * 2&#39; },
  { name: &#39;b&#39;, expr: &#39;a + 10&#39; },
  { name: &#39;c&#39;, expr: &#39;b * 3&#39; },
  { name: &#39;a&#39;, expr: &#39;5&#39; }
]);

// Automatically orders: a, b, c, d
console.log(result.order); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
console.log(result.values.d.toString()); // &quot;90&quot;
</code></pre>
<h3>Dot-Traversal with Object Literals</h3>
<p>Variable names must be simple identifiers (no dots), but expressions can use object literals and dot-notation:</p>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;point&#39;, expr: &#39;{x: 10, y: 20}&#39; },
  { name: &#39;offset&#39;, expr: &#39;{x: 5, y: 10}&#39; },
  { name: &#39;resultX&#39;, expr: &#39;point.x + offset.x&#39; },
  { name: &#39;resultY&#39;, expr: &#39;point.y + offset.y&#39; }
]);

console.log(result.values.resultX.toString()); // &quot;15&quot;
console.log(result.values.resultY.toString()); // &quot;25&quot;
</code></pre>
<h3>Nested Property Access</h3>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;data&#39;, expr: &#39;{pos: {x: 5, y: 10}, scale: 2}&#39; },
  { name: &#39;scaledX&#39;, expr: &#39;data.pos.x * data.scale&#39; }
]);

console.log(result.values.scaledX.toString()); // &quot;10&quot;
</code></pre>
<h3>Namespaces</h3>
<p>Variables may not begin with $, this is reserved for namespaces for built-in functions and constants.</p>
<h4>$math Namespace</h4>
<p>Mathematical constants and functions:</p>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;circumference&#39;, expr: &#39;2 * $math.PI * 10&#39; },
  { name: &#39;absVal&#39;, expr: &#39;$math.abs(-42)&#39; },
  { name: &#39;sqrtVal&#39;, expr: &#39;$math.sqrt(16)&#39; },
  { name: &#39;maxVal&#39;, expr: &#39;$math.max(10, 5, 20, 3)&#39; }
]);
</code></pre>
<p><strong>Available:</strong></p>
<ul>
<li>Constants: <code>PI</code>, <code>E</code>, <code>SQRT2</code>, <code>SQRT1_2</code>, <code>LN2</code>, <code>LN10</code>, <code>LOG2E</code>, <code>LOG10E</code></li>
<li>Functions: <code>abs</code>, <code>sqrt</code>, <code>cbrt</code>, <code>floor</code>, <code>ceil</code>, <code>round</code>, <code>trunc</code>, <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>asin</code>, <code>acos</code>, <code>atan</code>, <code>atan2</code>, <code>exp</code>, <code>ln</code>, <code>log</code>, <code>log10</code>, <code>log2</code>, <code>pow</code>, <code>min</code>, <code>max</code></li>
</ul>
<h4>$unit Namespace</h4>
<p>Unit conversion functions:</p>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;inches&#39;, expr: &#39;$unit.mmToInch(25.4)&#39; },
  { name: &#39;mm&#39;, expr: &#39;$unit.inchToMm(1)&#39; }
]);
</code></pre>
<p><strong>Available:</strong></p>
<ul>
<li><code>mmToInch</code>, <code>inchToMm</code></li>
<li><code>cmToInch</code>, <code>inchToCm</code></li>
<li><code>mToFt</code>, <code>ftToM</code></li>
</ul>
<h4>$angle Namespace</h4>
<p>Angle conversion functions:</p>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;radians&#39;, expr: &#39;$angle.toRad(180)&#39; },
  { name: &#39;degrees&#39;, expr: &#39;$angle.toDeg($math.PI)&#39; }
]);
</code></pre>
<p><strong>Available:</strong></p>
<ul>
<li><code>toRad</code> (degrees to radians)</li>
<li><code>toDeg</code> (radians to degrees)</li>
</ul>
<h3>Circular Dependency Detection</h3>
<pre><code class="language-typescript">try {
  await evalla([
    { name: &#39;a&#39;, expr: &#39;b + 1&#39; },
    { name: &#39;b&#39;, expr: &#39;a + 1&#39; }
  ]);
} catch (error) {
  console.log(error.message); // &quot;Circular dependency detected: b -&gt; a -&gt; b&quot;
}
</code></pre>
<h3>Variable naming</h3>
<p>Variables may not begin with a number, double underscore(__), or $ (see namespaces above).</p>
<h4>Keywords as Variable Names</h4>
<p>Unlike JavaScript, algebra-like variable names can include JavaScript keywords:</p>
<pre><code class="language-typescript">const result = await evalla([
  { name: &#39;return&#39;, expr: &#39;10&#39; },
  { name: &#39;if&#39;, expr: &#39;20&#39; },
  { name: &#39;for&#39;, expr: &#39;return + if&#39; }
]);

console.log(result.values.for.toString()); // &quot;30&quot;
</code></pre>
<h2>Security</h2>
<p><strong>Safe by design:</strong></p>
<ul>
<li>‚ùå No access to <code>eval()</code>, <code>Function()</code>, or other dangerous globals</li>
<li>‚ùå No access to <code>process</code>, <code>require</code>, or Node.js internals</li>
<li>‚ùå No access to dangerous properties: <code>prototype</code>, <code>__proto__</code>, <code>constructor</code>, or any property starting with <code>__</code></li>
<li>‚úÖ Only whitelisted functions in namespaces</li>
<li>‚úÖ Uses AST parsing (Peggy) + safe evaluation</li>
<li>‚úÖ Variable names cannot start with <code>$</code> (reserved for system)</li>
<li>‚úÖ Sandboxed scope with <code>Object.create(null)</code></li>
<li>‚úÖ No prototype pollution</li>
</ul>
<p><strong>Blocked property access examples:</strong></p>
<pre><code class="language-typescript">// These will throw SecurityError
await evalla([{ name: &#39;bad&#39;, expr: &#39;obj.prototype&#39; }]);
await evalla([{ name: &#39;bad&#39;, expr: &#39;obj.__proto__&#39; }]);
await evalla([{ name: &#39;bad&#39;, expr: &#39;obj.constructor&#39; }]);
await evalla([{ name: &#39;bad&#39;, expr: &#39;obj.__defineGetter__&#39; }]);
</code></pre>
<p>Properties starting with <code>__</code> are blocked because they typically provide access to JavaScript internals that could be exploited for prototype pollution or other security vulnerabilities.</p>
<h2>API</h2>
<h3><code>evalla(inputs: ExpressionInput[]): Promise&lt;EvaluationResult&gt;</code></h3>
<p>Evaluates an array of math expressions with dependencies.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>inputs</code>: Array of <code>{ name, expr }</code> objects</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>Promise resolving to <code>{ values, order }</code></li>
</ul>
<p><strong>Throws:</strong></p>
<ul>
<li><code>ValidationError</code> - Invalid input (missing name, duplicate names, invalid variable names)<ul>
<li>Properties: <code>variableName</code></li>
</ul>
</li>
<li><code>CircularDependencyError</code> - Circular dependencies detected<ul>
<li>Properties: <code>cycle</code> (array of variable names in the cycle)</li>
</ul>
</li>
<li><code>ParseError</code> - Syntax/parsing errors in expressions (extends <code>EvaluationError</code>)<ul>
<li>Properties: <code>variableName</code>, <code>expression</code>, <code>line</code>, <code>column</code></li>
</ul>
</li>
<li><code>EvaluationError</code> - Runtime evaluation errors (undefined variables, type errors)<ul>
<li>Properties: <code>variableName</code></li>
</ul>
</li>
<li><code>SecurityError</code> - Attempt to access blocked properties (prototype, <strong>proto</strong>, constructor, __*)<ul>
<li>Properties: <code>property</code></li>
</ul>
</li>
</ul>
<p>All errors include structured details for programmatic access - no need to parse error messages!</p>
<p><strong>Error Handling:</strong></p>
<pre><code class="language-typescript">import { evalla, ParseError, SecurityError, CircularDependencyError, ValidationError, EvaluationError } from &#39;evalla&#39;;

try {
  const result = await evalla(inputs);
} catch (error) {
  // Catch ParseError first since it extends EvaluationError
  if (error instanceof ParseError) {
    console.error(`Syntax error in &quot;${error.variableName}&quot; at ${error.line}:${error.column}`);
    console.error(`Expression: ${error.expression}`);
  } else if (error instanceof EvaluationError) {
    console.error(`Runtime error in &quot;${error.variableName}&quot;`);
  } else if (error instanceof SecurityError) {
    console.error(`Security violation: attempted to access &quot;${error.property}&quot;`);
  } else if (error instanceof CircularDependencyError) {
    console.error(`Circular dependency: ${error.cycle.join(&#39; -&gt; &#39;)}`);
  } else if (error instanceof ValidationError) {
    console.error(`Invalid variable: &quot;${error.variableName}&quot;`);
  }
}
</code></pre>
<h3><code>checkSyntax(expr: string): SyntaxCheckResult</code></h3>
<p>Checks the syntax of an expression without evaluating it. Useful for text editors to validate expressions before sending them for evaluation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>expr</code>: The expression string to check</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>Object with the following properties:<ul>
<li><code>valid</code>: boolean - Whether the syntax is valid</li>
<li><code>error?</code>: string - Error message if syntax is invalid</li>
<li><code>line?</code>: number - Line number where error occurred (1-indexed)</li>
<li><code>column?</code>: number - Column number where error occurred (1-indexed)</li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-typescript">import { checkSyntax } from &#39;evalla&#39;;

// Valid expression
const result1 = checkSyntax(&#39;a + b * 2&#39;);
console.log(result1.valid); // true

// Invalid expression - missing closing parenthesis
const result2 = checkSyntax(&#39;(a + b&#39;);
console.log(result2.valid); // false
console.log(result2.error); // &quot;Parse error at line 1, column 7: Expected...&quot;
console.log(result2.line); // 1
console.log(result2.column); // 7
</code></pre>
<p><strong>Usage Patterns:</strong></p>
<p>When to use <code>checkSyntax()</code> vs just calling <code>evalla()</code>:</p>
<pre><code class="language-typescript">import { checkSyntax, evalla, EvaluationError } from &#39;evalla&#39;;

// Pattern 1: Pre-validate for immediate user feedback (recommended for text editors/UI)
const inputs = [
  { name: &#39;a&#39;, expr: &#39;c + 5&#39; },
  { name: &#39;b&#39;, expr: &#39;a * 2&#39; }
];

// Check syntax of each expression before calling evalla
for (const input of inputs) {
  if (input.expr) {
    const check = checkSyntax(input.expr);
    if (!check.valid) {
      console.error(`Invalid syntax in &quot;${input.name}&quot;: ${check.error}`);
      return; // Don&#39;t call evalla with invalid syntax
    }
  }
}

// All syntax valid, now evaluate
const result = await evalla(inputs);

// Pattern 2: Let evalla handle all validation (simpler for batch processing)
try {
  const result = await evalla(inputs);
  // Success - use result
} catch (error) {
  // Catch ParseError specifically to handle syntax errors
  if (error instanceof ParseError) {
    console.error(`Syntax error in &quot;${error.variableName}&quot; at ${error.line}:${error.column}`);
  } else if (error instanceof EvaluationError) {
    console.error(&#39;Runtime evaluation error:&#39;, error.message);
  }
  // Handle other error types (ValidationError, CircularDependencyError, etc.)
}
</code></pre>
<p><strong>Note:</strong> </p>
<ul>
<li><code>checkSyntax()</code> only validates expression syntax. It does not check variable names, detect circular dependencies, or validate that referenced variables exist.</li>
<li><code>evalla()</code> throws <code>ParseError</code> for syntax errors with the same details (line, column, message) as <code>checkSyntax()</code>, plus identifies which variable has the error.</li>
<li><code>ParseError</code> extends <code>EvaluationError</code>, so catch <code>ParseError</code> first if you want to handle syntax errors differently from runtime errors.</li>
<li>Use <code>checkSyntax()</code> for pre-flight validation (e.g., real-time feedback as user types). Use <code>evalla()</code> for complete validation and evaluation.</li>
</ul>
<h2>Philosophy</h2>
<ul>
<li><strong>Minimal</strong>: Bare minimum dependencies and code</li>
<li><strong>Modular</strong>: Separated concerns (parser, evaluator, namespaces, toposort)</li>
<li><strong>DRY</strong>: No code duplication</li>
<li><strong>Testable</strong>: Small, focused functions with clear interfaces</li>
<li><strong>Safe &amp; Secure</strong>: No arbitrary code execution, whitelist-only approach</li>
<li><strong>Efficient</strong>: Parse once, use for both dependency extraction and evaluation</li>
</ul>
<h2>Development</h2>
<pre><code class="language-bash"># Install dependencies
npm install

# Build
npm run build

# Test
npm test
</code></pre>
<p>For detailed API documentation and examples, see the sections above.</p>
<h2>License</h2>
<p>MIT</p>
</div> </div> </body></html>