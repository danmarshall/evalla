#!/usr/bin/env node

/**
 * Sync README from packages/evalla to root with packages section injection
 * Also generates an Astro component with pre-rendered HTML for the web page
 */

const fs = require('fs');
const path = require('path');
const { marked } = require('marked');

const ROOT_DIR = path.join(__dirname, '..');
const EVALLA_README = path.join(ROOT_DIR, 'packages/evalla/README.md');
const ROOT_README = path.join(ROOT_DIR, 'README.md');
const COMPONENT_OUTPUT = path.join(ROOT_DIR, 'packages/playground/src/components/ReadmeContent.astro');

// The packages section to inject after the description
const PACKAGES_SECTION = `
## üéÆ Try the Playground

Visit the interactive playground to experiment with evalla in your browser! See the [playground README](packages/playground/README.md) for details.

## üì¶ Packages

This is a monorepo containing:

- **[evalla](packages/evalla/)** - Core math evaluator library
- **[playground](packages/playground/)** - Interactive Astro-based playground
`;

// Sections to exclude from web page (GitHub-only content)
const SECTIONS_TO_EXCLUDE = [
  '## üéÆ Try the Playground',
  '## üì¶ Packages'
];

function filterReadmeForWeb(readmeContent) {
  // Remove GitHub-only sections for the web page
  const lines = readmeContent.split('\n');
  const filteredLines = [];
  let skipSection = false;

  for (const line of lines) {
    // Check if we're at a section to exclude
    if (SECTIONS_TO_EXCLUDE.includes(line)) {
      skipSection = true;
      continue;
    }
    
    // Check if we've reached the next section (any other ## heading)
    if (skipSection && line.startsWith('## ')) {
      // Reached next section - stop skipping
      skipSection = false;
      filteredLines.push(line);
      continue;
    }
    
    // Skip lines if we're in a section to be removed
    if (skipSection) {
      continue;
    }
    
    filteredLines.push(line);
  }

  return filteredLines.join('\n');
}

async function generateAstroComponent(readmeContent) {
  console.log('üìù Generating Astro component with pre-rendered HTML...');
  
  // Filter out GitHub-only sections
  const filteredContent = filterReadmeForWeb(readmeContent);
  
  // Convert markdown to HTML
  const htmlContent = await marked(filteredContent);
  
  // Generate Astro component
  const astroComponent = `<!-- Auto-generated by sync-readme.js - DO NOT EDIT MANUALLY -->
<div class="content" set:html={\`${htmlContent.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`} />
`;
  
  // Ensure components directory exists
  const componentsDir = path.dirname(COMPONENT_OUTPUT);
  if (!fs.existsSync(componentsDir)) {
    fs.mkdirSync(componentsDir, { recursive: true });
  }
  
  // Write component file
  fs.writeFileSync(COMPONENT_OUTPUT, astroComponent, 'utf-8');
  console.log(`‚úÖ Component generated: ${COMPONENT_OUTPUT}`);
}

function syncReadme() {
  console.log('üîÑ Syncing README from packages/evalla to root...');

  // Read the master README from packages/evalla
  let evallaReadme = fs.readFileSync(EVALLA_README, 'utf-8');

  // Remove the "Try it Live" section from evalla README since we'll have "Try the Playground" in root
  // This avoids duplication
  const lines = evallaReadme.split('\n');
  const filteredLines = [];
  let skipSection = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Check if we're at the "Try it Live" section
    if (line.startsWith('## üéÆ Try it Live')) {
      skipSection = true;
      continue;
    }
    
    // Check if we've reached the next section or code block
    if (skipSection) {
      if (line.startsWith('## ') && !line.startsWith('## üéÆ')) {
        // Reached next section
        skipSection = false;
        filteredLines.push(line);
      } else if (line.startsWith('```typescript')) {
        // Reached the code block
        skipSection = false;
        filteredLines.push(line);
      }
      continue;
    }
    
    filteredLines.push(line);
  }
  
  // Now find where to inject the packages section (after title and description)
  let insertIndex = 0;
  let foundTitle = false;
  let foundDescription = false;
  
  for (let i = 0; i < filteredLines.length; i++) {
    const line = filteredLines[i];
    
    if (line.startsWith('# evalla')) {
      foundTitle = true;
      continue;
    }
    
    if (foundTitle && !foundDescription && line.trim() && !line.startsWith('##')) {
      foundDescription = true;
      continue;
    }
    
    // Insert before the first section heading after description
    if (foundDescription && (line.startsWith('##') || line.startsWith('```'))) {
      insertIndex = i;
      break;
    }
  }
  
  // Insert the packages section
  const updatedLines = [
    ...filteredLines.slice(0, insertIndex),
    ...PACKAGES_SECTION.trim().split('\n'),
    '',
    ...filteredLines.slice(insertIndex)
  ];
  
  const updatedReadme = updatedLines.join('\n');
  
  // Write to root README
  fs.writeFileSync(ROOT_README, updatedReadme, 'utf-8');
  
  console.log('‚úÖ README synced successfully!');
  console.log(`   Source: ${EVALLA_README}`);
  console.log(`   Target: ${ROOT_README}`);
  
  // Generate Astro component with pre-rendered HTML
  return updatedReadme;
}

// Run the sync
async function main() {
  const readmeContent = syncReadme();
  await generateAstroComponent(readmeContent);
  console.log('üéâ All done!');
}

main().catch(error => {
  console.error('Error:', error);
  process.exit(1);
});
